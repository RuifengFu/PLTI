// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function $$eval(_expr, _env) {
  while(true) {
    var env = _env;
    var expr = _expr;
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return expr._0;
      case /* Add */1 :
          return $$eval(expr._0, env) + $$eval(expr._1, env) | 0;
      case /* Mul */2 :
          return Math.imul($$eval(expr._0, env), $$eval(expr._1, env));
      case /* Var */3 :
          return List.assoc(expr._0, env);
      case /* Let */4 :
          _env = {
            hd: [
              expr._0,
              $$eval(expr._1, env)
            ],
            tl: env
          };
          _expr = expr._2;
          continue ;
      
    }
  };
}

var Expr1 = {
  $$eval: $$eval
};

function $$eval$1(_expr, _s) {
  while(true) {
    var s = _s;
    var expr = _expr;
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return expr._0;
      case /* Add */1 :
          return $$eval$1(expr._0, s) + $$eval$1(expr._1, s) | 0;
      case /* Mul */2 :
          return Math.imul($$eval$1(expr._0, s), $$eval$1(expr._1, s));
      case /* Var */3 :
          return List.nth(s, expr._0);
      case /* Let */4 :
          _s = {
            hd: $$eval$1(expr._0, s),
            tl: s
          };
          _expr = expr._1;
          continue ;
      
    }
  };
}

var Nameless = {
  $$eval: $$eval$1
};

function index(cenv, x) {
  var _cenv = cenv;
  var _n = 0;
  while(true) {
    var n = _n;
    var cenv$1 = _cenv;
    if (cenv$1) {
      if (Caml_obj.equal(cenv$1.hd, x)) {
        return n;
      }
      _n = n + 1 | 0;
      _cenv = cenv$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function compile1(expr, cenv) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                TAG: /* Cst */0,
                _0: expr._0
              };
    case /* Add */1 :
        return {
                TAG: /* Add */1,
                _0: compile1(expr._0, cenv),
                _1: compile1(expr._1, cenv)
              };
    case /* Mul */2 :
        return {
                TAG: /* Mul */2,
                _0: compile1(expr._0, cenv),
                _1: compile1(expr._1, cenv)
              };
    case /* Var */3 :
        return {
                TAG: /* Var */3,
                _0: index(cenv, expr._0)
              };
    case /* Let */4 :
        return {
                TAG: /* Let */4,
                _0: compile1(expr._1, cenv),
                _1: compile1(expr._2, {
                      hd: expr._0,
                      tl: cenv
                    })
              };
    
  }
}

function $$eval$2(_instrs, _stk) {
  while(true) {
    var stk = _stk;
    var instrs = _instrs;
    if (instrs) {
      var i = instrs.hd;
      if (typeof i === "number") {
        switch (i) {
          case /* Add */0 :
              if (stk) {
                var match = stk.tl;
                if (match) {
                  _stk = {
                    hd: stk.hd + match.hd | 0,
                    tl: match.tl
                  };
                  _instrs = instrs.tl;
                  continue ;
                }
                
              }
              break;
          case /* Mul */1 :
              if (stk) {
                var match$1 = stk.tl;
                if (match$1) {
                  _stk = {
                    hd: Math.imul(stk.hd, match$1.hd),
                    tl: match$1.tl
                  };
                  _instrs = instrs.tl;
                  continue ;
                }
                
              }
              break;
          case /* Pop */2 :
              if (stk) {
                _stk = stk.tl;
                _instrs = instrs.tl;
                continue ;
              }
              break;
          case /* Swap */3 :
              if (stk) {
                var match$2 = stk.tl;
                if (match$2) {
                  _stk = {
                    hd: match$2.hd,
                    tl: {
                      hd: stk.hd,
                      tl: match$2.tl
                    }
                  };
                  _instrs = instrs.tl;
                  continue ;
                }
                
              }
              break;
          
        }
      } else {
        if (i.TAG === /* Cst */0) {
          _stk = {
            hd: i._0,
            tl: stk
          };
          _instrs = instrs.tl;
          continue ;
        }
        _stk = {
          hd: Belt_List.getExn(stk, i._0),
          tl: stk
        };
        _instrs = instrs.tl;
        continue ;
      }
    } else if (stk) {
      return stk.hd;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Tiny1.res",
            83,
            11
          ],
          Error: new Error()
        };
  };
}

var Instr1 = {
  $$eval: $$eval$2
};

function compile2(expr) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return List.append(List.append(compile2(expr._0), compile2(expr._1)), {
                    hd: /* Add */0,
                    tl: /* [] */0
                  });
    case /* Mul */2 :
        return List.append(List.append(compile2(expr._0), compile2(expr._1)), {
                    hd: /* Mul */1,
                    tl: /* [] */0
                  });
    case /* Var */3 :
        return {
                hd: {
                  TAG: /* Var */1,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        return List.append(List.append(compile2(expr._0), compile2(expr._1)), {
                    hd: /* Swap */3,
                    tl: {
                      hd: /* Pop */2,
                      tl: /* [] */0
                    }
                  });
    
  }
}

function compile3(expr, cenv) {
  switch (expr.TAG | 0) {
    case /* Cst */0 :
        return {
                hd: {
                  TAG: /* Cst */0,
                  _0: expr._0
                },
                tl: /* [] */0
              };
    case /* Add */1 :
        return List.append(List.append(compile3(expr._0, cenv), compile3(expr._1, cenv)), {
                    hd: /* Add */0,
                    tl: /* [] */0
                  });
    case /* Mul */2 :
        return List.append(List.append(compile3(expr._0, cenv), compile3(expr._1, cenv)), {
                    hd: /* Mul */1,
                    tl: /* [] */0
                  });
    case /* Var */3 :
        return {
                hd: {
                  TAG: /* Var */1,
                  _0: index(cenv, expr._0)
                },
                tl: /* [] */0
              };
    case /* Let */4 :
        return List.append(List.append(compile3(expr._1, cenv), compile3(expr._2, List.append(cenv, {
                                hd: expr._0,
                                tl: /* [] */0
                              }))), {
                    hd: /* Swap */3,
                    tl: {
                      hd: /* Pop */2,
                      tl: /* [] */0
                    }
                  });
    
  }
}

function test_compile(src) {
  var compiled = compile2(compile1(src, /* [] */0));
  var computed = $$eval$2(compiled, /* [] */0);
  console.log("" + computed);
  if (computed === $$eval(src, /* [] */0)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Tiny1.res",
          118,
          4
        ],
        Error: new Error()
      };
}

function test_compile2(src) {
  var compiled = compile3(src, /* [] */0);
  var computed = $$eval$2(compiled, /* [] */0);
  console.log("" + computed);
  if (computed === $$eval(src, /* [] */0)) {
    return ;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Tiny1.res",
          125,
          4
        ],
        Error: new Error()
      };
}

var tests = [
  {
    TAG: /* Cst */0,
    _0: 42
  },
  {
    TAG: /* Add */1,
    _0: {
      TAG: /* Cst */0,
      _0: 1
    },
    _1: {
      TAG: /* Cst */0,
      _0: 2
    }
  },
  {
    TAG: /* Mul */2,
    _0: {
      TAG: /* Cst */0,
      _0: 1
    },
    _1: {
      TAG: /* Cst */0,
      _0: 2
    }
  },
  {
    TAG: /* Add */1,
    _0: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Cst */0,
        _0: 1
      },
      _1: {
        TAG: /* Cst */0,
        _0: 2
      }
    },
    _1: {
      TAG: /* Cst */0,
      _0: 3
    }
  },
  {
    TAG: /* Mul */2,
    _0: {
      TAG: /* Mul */2,
      _0: {
        TAG: /* Cst */0,
        _0: 1
      },
      _1: {
        TAG: /* Cst */0,
        _0: 2
      }
    },
    _1: {
      TAG: /* Cst */0,
      _0: 3
    }
  },
  {
    TAG: /* Add */1,
    _0: {
      TAG: /* Mul */2,
      _0: {
        TAG: /* Cst */0,
        _0: 1
      },
      _1: {
        TAG: /* Cst */0,
        _0: 2
      }
    },
    _1: {
      TAG: /* Cst */0,
      _0: 3
    }
  },
  {
    TAG: /* Mul */2,
    _0: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Cst */0,
        _0: 1
      },
      _1: {
        TAG: /* Cst */0,
        _0: 2
      }
    },
    _1: {
      TAG: /* Cst */0,
      _0: 3
    }
  },
  {
    TAG: /* Let */4,
    _0: "x",
    _1: {
      TAG: /* Cst */0,
      _0: 2
    },
    _2: {
      TAG: /* Add */1,
      _0: {
        TAG: /* Var */3,
        _0: "x"
      },
      _1: {
        TAG: /* Var */3,
        _0: "x"
      }
    }
  },
  {
    TAG: /* Let */4,
    _0: "x",
    _1: {
      TAG: /* Cst */0,
      _0: 3
    },
    _2: {
      TAG: /* Mul */2,
      _0: {
        TAG: /* Add */1,
        _0: {
          TAG: /* Var */3,
          _0: "x"
        },
        _1: {
          TAG: /* Cst */0,
          _0: 1
        }
      },
      _1: {
        TAG: /* Cst */0,
        _0: 2
      }
    }
  },
  {
    TAG: /* Let */4,
    _0: "x",
    _1: {
      TAG: /* Cst */0,
      _0: 5
    },
    _2: {
      TAG: /* Mul */2,
      _0: {
        TAG: /* Var */3,
        _0: "x"
      },
      _1: {
        TAG: /* Cst */0,
        _0: 2
      }
    }
  },
  {
    TAG: /* Let */4,
    _0: "x",
    _1: {
      TAG: /* Cst */0,
      _0: 1
    },
    _2: {
      TAG: /* Let */4,
      _0: "y",
      _1: {
        TAG: /* Cst */0,
        _0: 4
      },
      _2: {
        TAG: /* Add */1,
        _0: {
          TAG: /* Var */3,
          _0: "x"
        },
        _1: {
          TAG: /* Var */3,
          _0: "y"
        }
      }
    }
  }
];

function test1(param) {
  Belt_Array.forEachWithIndex(tests, (function (i, t) {
          test_compile(t);
          var i$1 = i + 1 | 0;
          console.log("Test1: test " + i$1 + " passed");
        }));
}

function test2(param) {
  Belt_Array.forEachWithIndex(tests, (function (i, t) {
          test_compile2(t);
          var i$1 = i + 1 | 0;
          console.log("Test1: test " + i$1 + " passed");
        }));
}

var Test1 = {
  test_compile: test_compile,
  test_compile2: test_compile2,
  tests: tests,
  test1: test1,
  test2: test2
};

test1(undefined);

test2(undefined);

function sindex(senv, i) {
  var _senv = senv;
  var _i = i;
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var i$1 = _i;
    var senv$1 = _senv;
    if (senv$1) {
      if (senv$1.hd) {
        _acc = acc + 1 | 0;
        _senv = senv$1.tl;
        continue ;
      }
      if (i$1 === 0) {
        return acc;
      }
      _acc = acc + 1 | 0;
      _i = i$1 - 1 | 0;
      _senv = senv$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function scompile(expr) {
  var go = function (expr, senv) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return {
                  hd: {
                    TAG: /* Cst */0,
                    _0: expr._0
                  },
                  tl: /* [] */0
                };
      case /* Add */1 :
          return Belt_List.concatMany([
                      go(expr._0, senv),
                      go(expr._1, {
                            hd: /* Stmp */1,
                            tl: senv
                          }),
                      {
                        hd: /* Add */0,
                        tl: /* [] */0
                      }
                    ]);
      case /* Mul */2 :
          return Belt_List.concatMany([
                      go(expr._0, senv),
                      go(expr._1, {
                            hd: /* Stmp */1,
                            tl: senv
                          }),
                      {
                        hd: /* Mul */1,
                        tl: /* [] */0
                      }
                    ]);
      case /* Var */3 :
          return {
                  hd: {
                    TAG: /* Var */1,
                    _0: sindex(senv, expr._0)
                  },
                  tl: /* [] */0
                };
      case /* Let */4 :
          return Belt_List.concatMany([
                      go(expr._0, senv),
                      go(expr._1, {
                            hd: /* Slocal */0,
                            tl: senv
                          }),
                      {
                        hd: /* Swap */3,
                        tl: {
                          hd: /* Pop */2,
                          tl: /* [] */0
                        }
                      }
                    ]);
      
    }
  };
  return go(expr, /* [] */0);
}

var NamelessToStackVM = {
  sindex: sindex,
  scompile: scompile
};

function sindex$1(senv, s) {
  var _senv = senv;
  var _acc = 0;
  while(true) {
    var acc = _acc;
    var senv$1 = _senv;
    if (senv$1) {
      var x = senv$1.hd;
      if (x) {
        if (x._0 === s) {
          return acc;
        }
        _acc = acc + 1 | 0;
        _senv = senv$1.tl;
        continue ;
      }
      _acc = acc + 1 | 0;
      _senv = senv$1.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  };
}

function scompile$1(expr) {
  var go = function (expr, senv) {
    switch (expr.TAG | 0) {
      case /* Cst */0 :
          return {
                  hd: {
                    TAG: /* Cst */0,
                    _0: expr._0
                  },
                  tl: /* [] */0
                };
      case /* Add */1 :
          return Belt_List.concatMany([
                      go(expr._0, senv),
                      go(expr._1, {
                            hd: /* Stmp */0,
                            tl: senv
                          }),
                      {
                        hd: /* Add */0,
                        tl: /* [] */0
                      }
                    ]);
      case /* Mul */2 :
          return Belt_List.concatMany([
                      go(expr._0, senv),
                      go(expr._1, {
                            hd: /* Stmp */0,
                            tl: senv
                          }),
                      {
                        hd: /* Mul */1,
                        tl: /* [] */0
                      }
                    ]);
      case /* Var */3 :
          return {
                  hd: {
                    TAG: /* Var */1,
                    _0: sindex$1(senv, expr._0)
                  },
                  tl: /* [] */0
                };
      case /* Let */4 :
          return Belt_List.concatMany([
                      go(expr._1, senv),
                      go(expr._2, {
                            hd: /* Slocal */{
                              _0: expr._0
                            },
                            tl: senv
                          }),
                      {
                        hd: /* Swap */3,
                        tl: {
                          hd: /* Pop */2,
                          tl: /* [] */0
                        }
                      }
                    ]);
      
    }
  };
  return go(expr, /* [] */0);
}

var ExprToStackMV = {
  sindex: sindex$1,
  scompile: scompile$1
};

var app = List.append;

var concatMany = Belt_List.concatMany;

export {
  Expr1 ,
  Nameless ,
  index ,
  compile1 ,
  Instr1 ,
  app ,
  compile2 ,
  compile3 ,
  Test1 ,
  concatMany ,
  NamelessToStackVM ,
  ExprToStackMV ,
}
/*  Not a pure module */
